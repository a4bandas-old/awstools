#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'fileutils'
require 'fog'

options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [-c credential] [-n notification script] [-f force] [-l] file1..fileN"

  options[:credential] = :otlive
  opts.on( '-c', '--credential CRED', 'Use specific credentials from ~/.fog' ) do |cred|
    options[:credential] = cred.to_sym
  end
  opts.on( '-n', '--notify SCRIPT', 'Call SCRIPT when hosts changed' ) do |script|
    options[:notify] = script
  end
  opts.on( '-f', '--force', 'Force update of target files' ) do
    options[:force] = true
  end
  opts.on( '-l', '--list-running', 'Show running hosts' ) do
    options[:list_running] = true
  end
end
optparse.parse!

if ARGV.length == 0 && !options[:list_running]
  puts optparse
  exit
end

Fog.credential = options[:credential]

HOSTS_STAT_FILE    = File.expand_path '~/.' + options[:credential].to_s + '-hosts.status'
AUTO_GENERATED_STR = options[:credential].to_s + '-autogenerated'

def load_hosts(filename)
  hosts = {}
  if File.exists? filename
    File.open(filename, "r") do |infile|
      infile.each do |line|
        if line.include? AUTO_GENERATED_STR
          ip, name = line.split
          host, type = name.split '.'
          hosts[host] ||= {}
          hosts[host][type.to_sym] = ip
        end
      end
    end
  end
  hosts.keys.sort.map {|k| hosts[k].merge(:host => k) }
end

def save_hosts(filename, hosts)
  File.open(filename, "w") do |outfile|
    hosts.each do |host|
      outfile.puts "#{host[:public]} #{host[:host]}.public ##{AUTO_GENERATED_STR}"
      outfile.puts "#{host[:private]} #{host[:host]}.private ##{AUTO_GENERATED_STR}"
    end
  end
end

def get_running_hosts(show = false)
  ec2 = Fog::Compute.new(:provider => 'AWS')
  hosts = {}
  ec2.servers.all.each do |server|
    if server.state == 'running'
      hosts[server.tags['role']] = { :public => server.ip_address, :private => server.private_ip_address }
      if show
        puts "host: #{server.tags['role']}, public: #{server.ip_address}, private: #{server.private_ip_address}"
      end
    end
  end
  hosts.keys.sort.map {|k| hosts[k].merge(:host => k) }
end

def update_file(filename, hosts)
  lines = []
  File.open(filename, "r") do |infile|
    lines = infile.readlines
  end
  File.open(filename + '.tmp', "w") do |outfile|
    inside_autogen = false
    lines.each do |line|
      if md = line.match(/#{AUTO_GENERATED_STR}\s+match:\s*(\S+)\s*template:(.+)$/)
        inside_autogen = true
        outfile.puts line
        match, template = md[1,2]
        hosts.each do |host|
          if host[:host]
            if host[:host].match(match)
              outfile.puts template.gsub(/\{(\S+)\}/) { host[$1.to_sym] }
            end
          else
            puts hosts.inspect
          end
        end
      end
      if line.match(/#{AUTO_GENERATED_STR}\s+end/)
        inside_autogen = false
      end
      unless inside_autogen
        outfile.puts line
      end
    end
  end
  FileUtils.move(filename + '.tmp', filename)
end

saved_hosts = load_hosts(HOSTS_STAT_FILE)

if options[:list_running]
  puts "# Running hosts for '#{options[:credential]}'"
end

running_hosts = get_running_hosts(options[:list_running])

if running_hosts != saved_hosts || options[:force]
  save_hosts(HOSTS_STAT_FILE, running_hosts)
  ARGV.each do |file|
    update_file(file, running_hosts)
  end
  if options[:notify]
    system options[:notify]
  end
  puts "Changes updated!"
end

